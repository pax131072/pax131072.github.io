---
title: 一篇文章帶你看懂 Git flow、Github flow 和 Gitlab flow
date: 2025-06-12
tags: [git]
---

昨天重新理解了幾種主流的 git 版控方法，用文章稍微紀錄一下。

Git 版控應該是前後端、運維、測試 ...等所有軟體工程師的共同必修之一。它是程式的追蹤管理工具，類似於 gira, trello 等工具，軟體工程師如果在程式上沒有一致且可追蹤的進度，整個團隊會隨著「系統」的規模出現無法協作的狀況：不知道 A 修改了系統的哪裡？B 剛才把什麼東西打掉了？無法還原錯誤、無法修正前些時日的問題，造成重工、無用工、與不可估量的損失。但今天先不討論 add, commit, branch, merge ...等 git 為程式版控所提供的的功能，這邊都先假定各位已經知道那些指令的用途，我們來聊聊目前市面上的公司或團隊中，比較主流（或者說比較常見）的 3 種版本迭代流程：Git flow, Github flow 和 Gitlab flow。

## Git flow

三種工作流裡，最早出現的應該是 Git flow。大約在 2008-2010 年，那是一個 facebook 還不知名、github 剛成立、大家都還只會在 stackovweflow 或 Yahoo 奇摩知識 + 問問題的時代，大型系統開發的相關學問還沒有一個很標準的做法，多人協作的程式版本非常混亂，也充滿風險。每一次的 commit 都在跟運氣博弈、每一個大型版本的發布，背後都承載著無數工程師的寄託與禱告。在那樣的環境下，Vincent Driessen 提出了一種[改進版本協作的 git 使用方案](https://nvie.com/posts/a-successful-git-branching-model/)，該方案在推出之後就迅速成為主流，基本上它影響了後續所有大型系統的 git 管理指南，這套方案就是現在所說的 **Git flow**。

![Git flow 流程圖](images/git-work-flows-in-one-guide/git-flow.png)

Git flow 主要由 5 個分支所組成，分別是 2 個常駐分支（master 和 develop）和 3 個暫時分支（feature, release, and hotfix）組成。常駐分支顧名思義，是無論開發完成與否都會持續存在的分支，master 分支就是給外人看的、發布正式用的 main branch，而 develop 則是開發用的、供內部使用的工作分支；而暫時分支分為三種，分別為個人或小組用（feature）、開發完成後的發布前測試（release）、和發布之後的緊急熱修（hitfix）。Git flow 與其他兩種開發流最大的差別是【**Git flow 存在著明確的開發起點與開發終點**。】這種方案很適合具有明確開發節點的工作團隊，但不適合隨時都有新功能在同步開發的工作流程。

Git flow 開始於 develop。

在上個版本發布後，如果經過熱修或其他更改，master 與 develop 的程式會存在著一些微小但重要的差異，develop 首先要做的事情，就是把這些差異都給更新進來，因此第一個 develop commit 會是從 master（或 hotfix）合併回來的 commit，接著工作團隊會基於這個初始的 develop 節點，長出各自的工作分支（feature1, feature2, ...等）。理論上來說，每個 feature 的工作內容是相互獨立、互不影響的，各小組會透過若干個不同的 commits 完成自己的工作，之後就會被合併到 develop 裡面，並刪除自己原本的 feature 分支。待所有的 features 都合併回 develop 之後，第一階段的開發就算完成。

再來比較資深的團隊成員（可能是組長或主管？）會基於這個「合併完所有 features 的 develop 節點」開出一個 release 分支，release 的用途是整合所有當期的新功能、協調測試、驗收，這一過程的長度不定，有可能會在 1 天內完成，也有可能會進行 1-2 個禮拜。總之 release 調整完後，它就會被提交到 master 分支，成為一個新的正式版本，develop 也會把 release merge 回來，為下一次的開發作準備。而當版本提交到線上之後，如果有遇到緊急問題，通常不會再重走一輪開發慢慢處理，會是在 master 裡加開 hotfix 緊急分支，快速修復快速上版，而當熱修結束，就算是走完一個完整的「開發週期」。後續當 develop 把 hotfix 過的 master 分支 merge 回去，就是新一輪的開發起點了。

## Github flow

儘管 Git flow 已廣為人知，但對於小型專案來說（特別是以 GitHub 上的各類開源專案），它們實際上很難完全遵循其完整的開發流程，這與大型專案的開發情境大不相同。對於它們來說：比起完整的、一致性的開發間隔，小型專案更加依賴快速的、不定期的、來自各種地方的功能迭代，試想如果 GitHub 上的所有開源專案都制定了明確的開發規章、與嚴格的流程門檻，那麼外部貢獻者的參與意願應該也會大幅降低。因此，對於這些專案而言，比起「流程的一致性」，「靈活性」往往會更為重要。可能開發者 A 只是在這個週末提交一個 bugfix，但開發者 B 卻在隨後的 2 天一口氣新增 6-7 種功能。這種以快速試驗與社群驅動為主的開發方式，使得 Git flow 在這類場景下顯得過於繁瑣而不合時宜。

因此，Github flow 就誕生了：

![Github flow 流程圖](images/git-work-flows-in-one-guide/github-flow.png)

嚴格來說，Github flow 就是「經過整理的 git commits。」它並未刻意規範分支的種類與命名，也不強調釋出節點的流程：專案的常駐分支只有 master 分支一條，每次在對專案進行修改時，開發者僅需從 master 分支切出一個簡單的 feature，並於本地測試之後，就可以發送 PR（Pull Request）回 master，讓 master 的管理者進行審核與發布，過程中不會有 develop, release 等分支的參與或介入。這樣種快速的、不穩定的、變動頻率高的開發節奏流程。**非常適合正在快速演進的小型專案或新創團隊**。相較於笨重的 Git flow，它反而更加務實，也更契合版本的開發迭代。

Github flow 雖然簡單，但別小看這種簡單，因為它確實帶來了幾個原本 Git flow 所沒有的特性：首先是易於理解。在小型專案上，對於新手開發者而言，他不需要知道什麼是 develop、release、hotfix 等不同用途的分支，也不需要理解常駐跟非常駐等不同的分支特性，他只需要知道「master 分支的任一節點都是可使用的穩定版本，我只要在其中一個版本開出分支，並且完成我的新功能，然後提交給 master 審核，工作就結束了。」其次，Github flow 帶來了一項 Git flow 所不具備的關鍵特性──支援持續整合與持續部署（CI/CD）。由於 Github flow 不強調明確的開發起點與終點，而是鼓勵在 main 分支任意節點持續進行小單位的變更與佈署，因此 CI/CD 能夠更順暢地被整合進開發週期中。每一次 PR 都成為觸發測試與部署流程的契機，使得整體交付流程更為自動化與即時。

## Gitlab flow

![Gitlab flow 流程圖](images/git-work-flows-in-one-guide/gitlab-flow.png)

那有沒有一種可能？我們可以設計一種開發流，把 Git flow 的「一致、穩定」與 Github flow 的「快速、靈活」都合併在一起呢？有的，這種同時兼具一致穩定與快速靈活的解法，就是 Gitlab flow。**Gitlab flow 最大的特點是：它是環境導向的**。我們可以把 Gitlab flow 想像成「具有多個不同常駐分支的 Github flow。」正如附圖所示，在最簡單的情境下，Gitlab flow 裡通常會存在兩條常駐分支，分別是代表正式環境、生產環境、外部環境的 master 分支；以及代表開發環境、測試環境、內部環境的 staging 分支。實際的開發流程則像下面這樣：

首先，當開發者要開發新功能時，他同樣會從當前的 master 節點劃出新的 feature 分支，同時，類似於 Git flow，當開發者完成 feature 上的功能時，我們並不允許他直接把功能 merge 回外部環境（master）上。相反地，他需要先將完成的 feature 合併到測試環境（也就是 staging 分支），對功能進行審核與測試，如果功能出現問題，feature 就需要在原本的節點上繼續更新，然後繼續提交到 staging 上測試，直到功能完整了、沒問題了，才可以在主管（或資深前輩）的同意下發起 PR，讓 feature 合併到外部環境（master）上面，並透過 CI/CD ...等機制自動將 master 的版本進行更新發布。

在這樣的場景下，對於 feature 分支來說：feature 原本就是從 master 延伸出來的，所以 feature 只要不把 staging 的提交 merge 回來，我們就可以把 feature 視為「乾淨」的內容，即便它之後把不完整的功能安裝在 staging 上面，會弄髒的環境也會是 staging，不是 master；同時對 staging 分支來說：雖然 features 可能會提交錯誤的、不完整的功能給它，但這本來就是 staging 的職責（提供 features 一個可測試的環境），因此髒亂了也無妨；而對 master 分支來說，它唯一會更新的情況就只有「當 feature 測試完新功能時」，因此我們也可以確保 master 即便在快速迭代的情況下，也能夠每次都發布正確的、完整的嶄新功能，即便出現了問題，也可以透過 hotfix 快速修復。

最後，在真實的運作下，除了上述這種 master + staging 的 2 條常駐分支策略以外，視專案的規模大小，Gitlab flow 也可能會存在 production 分支、pre-production 分支、release 分支、test 分支、UAT 分支 ...等不同的常駐分支，這些分支通常會對應到一組或多組不同的系統環境（可能是更嚴格的版本控制，也可能是專門給測試團隊、行銷團隊、或客戶內部開發人員使用的獨立環境）。透過將相同的程式依次佈署在不同環境下，RD 團隊就可以更精確地控制版本的推進節奏；QA 團隊可以在特定環境對新功能進行各種壓力測試、邊緣案例測試 ...而不用擔心會弄壞開發環境；營銷團隊也能對外提供一個相對有利於 demo 的系統版本供客戶使用，同時團隊各自互不干擾，提升環境的穩定。

#### 後記

總的來說，雖然 Git flow、Github flow、Gitlab flow 看似只是分支命名與合併順序的不同，但在實務操作中，它們背後所隱含的是對團隊協作模式、產品穩定性要求、交付頻率與風險控管的大範圍思考。比起盲目地認為「專案就是一定要用 xxx flow 來跑！」分析專案的開發背景、選擇一套適合自己團隊的開發流程，並持續根據實際狀況微調，才是長期維運與技術成長的關鍵。畢竟也沒有人說要一套用到底，或許在開發初期團隊選擇了 Github flow 快速迭代；成長茁壯之後轉化成了 Gitlab flow 進行多環境驗證；最後比起新功能，公司的方針慢慢偏向持續與穩定，這種時候如果再轉成 Git flow，就是一個非常好的選擇。