---
title: 一篇文章帶你看懂 Git flow, Github flow 和 Gitlab flow
date: 2025-06-12
tags: [git]
---

昨天重新理解了幾種主流的 git 版控方法，用文章稍微紀錄一下。

Git 版控應該是前後端、運維、測試 ...等所有軟體工程師的共同必修之一。它是程式的追蹤管理工具，類似於 gira, trello 等工具，軟體工程師如果在程式上沒有一致且可追蹤的進度，整個團隊會隨著「系統」的規模出現無法協作的狀況：不知道 A 修改了系統的哪裡？B 剛才把什麼東西打掉了？無法還原錯誤、無法修正前些時日的問題，造成重工、無用工、與不可估量的損失。但今天先不討論 add, commit, branch, merge ...等 git 為程式版控所提供的的功能，這邊都先假定各位已經知道那些指令的用途，我們來聊聊目前市面上的公司或團隊中，比較主流（或者說比較常見）的 3 種版本迭代流程：git-flow, github-flow 和 gitlab-flow。

## Git flow

三種工作流裡，最早出現的應該是 git flow。大約在 2008-2010 年，那是一個 facebook 還不知名、github 剛成立、大家都還只會在 stackovweflow 或 Yahoo 奇摩知識 + 問問題的時代，大型系統開發的相關學問還沒有一個很標準的做法，多人協作的程式版本非常混亂混亂，也充滿風險。每一次的 commit 都在跟運氣博弈、每一個大型版本的發布，背後都承載著無數工程師的寄託與禱告。在那樣的環境下，Vincent Driessen 提出了一種[改進版本協作的 git 使用方案](https://nvie.com/posts/a-successful-git-branching-model/)，該方案在推出之後就迅速成為主流，基本上它影響了後續 5-10 年間所有大型系統的 git 管理指南，這套方案就是現在所說的 **Git flow**。

![git flow 流程圖](images/git-work-flows-in-one-guide/git-flow.png)

Git flow 主要由 5 個主要分支所組成，分別是 2 個常駐分支（master 和 develop）和 3 個暫時分支（feature, release, hotfix）組成。常駐分支顧名思義，是無論開發完成與否都會持續存在的分支，master 分支就是給外人看的、發布正式用的 main branch，而 develop 則是開發用的、供內部使用的工作分支；而暫時分支分為三種，分別為個人或小組用（feature）、開發完成後的發布前測試（release）、和發布之後的緊急熱修（hitfix）。Git flow 與其他兩種工作留最大的差別是【**Git flow 存在著明確的開發起點與開發終點**。】這種方案很適合具有明確開發節點的工作團隊，但不適合隨時都有新功能在同步開發的工作流程。

Git flow 開始於 develop。

在上個版本發布後，如果經過熱修或其他更改，master 與 develop 的程式會存在著一些微小但重要的差異，develop 首先要做的事情，就是把這些差異都給更新進來，因此第一個 develop commit 會是從 master（或 hotfix）合併回來的 commit，接著個工作團隊會基於這個初始的 develop 節點長出各自的工作分支（feature1, feature2, ...等）。理論上來說，每個 feature 的工作內容是相互獨立、互不影響的，各小組會透過若干個不同的 commits 完成自己的工作，之後就會被合併到 develop 裡面，並刪除自己原本的 feature 分支。待所有的 features 都合併回 develop 之後，第一階段的開發就算完成。

再來比較資深的團隊成員（可能是組長或主管？）會基於這個「合併完所有 features 的 develop 節點」開出一個 release 分支，release 的用途是整合所有當期的新功能、與協調測試驗收，這個過程長度不定，以自己聽過的經驗來看，有的只會在 1 天內就完成所有的測試驗收與系統整合，有的則會給出跟純開發類似的工作長度。總之 release 調整完後，它就會被提交到 master 分支，成為一個新的正式版本，develop 也會把 release merge 回來，為下一次的開發作準備（然後 release 就可以刪掉了）。最後是 hotfix：當版本提交到線上之後，如果有遇到緊急問題，通常不會再重走一輪開發慢慢處理，會是在 master 裡加開 hotfix 緊急分支，快速修復快速上版，而當熱修結束，就算是走完一個完整的「開發週期」（也就是附圖裡左邊的綠圈圈到右邊的藍圈圈）。後續 develop 重新 merge 回被 hotfix 修正過後的 master，就是新一輪的開發起點了。

## Github flow

儘管 Git Flow 已廣為人知，但對於小型專案來說（特別是以 GitHub 上的各類開源專案），它們實際上很難完全遵循其完整的開發流程，這與大型專案的開發情境大不相同。對於他們來說：比起完整的、一致性的開發間隔，小型專案更加依賴快速的、不定期的、來自各種地方的專案迭代，試想如果 GitHub 上的所有開源專案都制定了明確的開發規章、與嚴格的流程門檻，那麼將大幅降低外部貢獻者的參與意願。因此，對於這些專案而言，「靈活性」往往會比「流程的一致性」更為重要。開發者可能只是週末提交一個 bugfix、偶爾新增功能。這種以快速試驗與社群驅動為主的開發方式，使得 Git Flow 在這類場景下顯得過於繁瑣而不合時宜。

因此，Github flow 就誕生了：

![github flow 流程圖](images/git-work-flows-in-one-guide/github-flow.png)

嚴格來說，Github flow 就是「經過整理的 git commits」，時間點上甚至出現的比 git-flow 還要來的早。它並未刻意規範分支的種類與命名，也不強調釋出節點的流程：專案的常駐分支只有 master 分支一條，每次在對專案進行修改時，開發者僅需從 master 分支切出一個簡單的 feature，並於本地測試之後，發送 PR（Pull Request）回 master，再讓 master 分支的管理者經過基本的測試與審核後，即可合併並發布。這樣種快速的、不穩定的、變動頻率高的開發節奏流程。**非常適合正在快速演進的小型專案或新創團隊**。相較於笨重的 git flow，它反而更加務實，也更契合版本的開發迭代。

github flow 雖然簡單，但別小看這種簡單，gitlab flow 確實帶來了幾個 git flow 所沒有的特性：首先是易於理解，在小型專案上，對於新手開發者而言，他不需要知道什麼是 develop、release、hotfix 等不同用途的分支，也不需要理解常駐跟不常駐等不同的分支特性，他只需要知道「master 分支的任一節點都是可使用的穩定版本，我只要在其中一個版本開出分支，並且完成我的新功能，然後提交給 master 審核，工作就結束了。」其次，gitHub flow 帶來了一項 git flow 所不具備的關鍵特性──支援持續整合與持續部署（CI/CD）。由於 github flow 不強調明確的開發起點與終點，而是鼓勵在 main 分支任意節點持續進行小單位的變更與佈署，因此 CI/CD 能夠更順暢地被整合進開發週期中。每一次 PR 都成為觸發測試與部署流程的契機，使得整體交付流程更為自動化與即時。

## Gitlab flow

![gitlab flow 流程圖](images/git-work-flows-in-one-guide/gitlab-flow.png)

那有沒有一種可能？我們可以設計一種開發流，把 git flow 的「一致、穩定」與 github flow 的「快速、靈活」都合併在一起呢？有的，這種同時兼具一致穩定與快速靈活的解法，就是 gitlab flow。**Gitlab flow 最大的特點是：它是環境導向的**。一個簡易的 gitlab flow 就如附圖：master 和 develop 為常駐分支，而 feature 與 hotfix 則為暫時分支。在 gitlab flow 的環境下，每條常駐分支會對應著一個實體的系統環境，例如 master 就是正式環境、發布用環境、生產環境 ...等，而 develop 可能就是測試環境、開發用環境、內部環境 ...等。develop 分支最早會是從 master 分岔出來的，但在經過時間的迭代之下，兩分支長得完全不一樣的狀況會顯得非常常見。

遵循著 github flow，當開發者需要開發新功能時他只需要從當前的 master 節點劃出新的分支即可，同時類似於 git flow，當開發者完成 feature 的功能時，他並不允許直接被 merge 回 master 身上，相反地，他需要先將完成的功能合併到 develop（也就是開發環境上）進行審核、測試，過程中如果出現問題，develop 不會 merge 回 feature，反倒是 feature 需要在原本的節點上繼續更新，然後繼續提交到 develop 上不停測試，直到功能完整了、沒問題了，才可以在主管（或資深前輩）的同意下發起 PR，讓這一個功能合併到已經正常運行的 master 分支上面，而後進行 CI/CD 等後續操作。

對於 feature 分支來說：feature 原本就是從 master 延伸出來的，所以 feature 只要不把 develop 的提交 merge 回來，我們就可以把 feature 視為是「乾淨」的內容，即便它之後把不完整的功能安裝在 develop 上面，會弄髒的環境也會是 develop，不是 master。而在最最單純的架構上（意思是有更複雜的 gitlab flow 但現在先不提），當 feature 把功能都做完之後，feature 需要做的事情就只是「把新的、做好的、完整的功能 merge 回 master 上面。」不需要等待其餘 feature 開發完成、也不需要 release 環境測試 ...等，免除了 git flow 裡面的繁冗事務。

而對 develop 分支來說：雖然不同的 features 可能會提交錯誤的、不完整的功能給它，但 develop 的職責本來就是測試環境、開發用環境、內部環境，髒亂了也無妨，畢竟誰能夠保證自己寫得程式永遠都不會有問題，永遠都不會有 bug？況且，弄髒了又怎麼樣？說到底這也只是一個給內部開發人員使用的分支，並不是給客戶的正式產品，因此只要能夠保證 develop 分支不會 merge 回 master，把 develop 破壞的再髒亂也沒有問題。而且，「把 develop merge 回 master」這項操作，在 gitlab flow 裡面本來就是需要極力避免甚至是嚴格禁止的，因此這種情況也不需要擔心。

最後，對於 master 分支來說，雖然它不像 git flow 有明確的開發終點，可能時不時就會有 1-2 個 features 會需要合併上來（所以版號的問題可能是一個不小的困擾），但在 gitlab flow 的架構下，即便時不時就有新的功能需要合到正式版本，但 master 不需要太過擔心「功能是不是不完整，可能有問題」的這一情況，因為通常來說，feature 在發 PR 給 master 之前，已經經過多次 develop 環境上的測試了，當然偶爾還是會遇到一些只有正式環境上才會出現的問題（所以 hotfix 仍然存在），只過在絕大多數的情況下，master 只需要信任 feature 的內容，允許 PR，就可以期待一個新功能的實裝與運行。

#### 後記

以我的經驗來看，在實際的情況下，只要是稍微具有規模一點的公司，走的應該都是 gitlab flow 這種流程，而公司內部的常駐分支也不會只有 master（或者更常稱呼為 main？）跟 develop 兩條而已。正式環境、準正式環境、UAT 環境、灰度環境、測試環境 ...不同的公司對於環境的命名與定義會有所不同。這些環境通常會對應到一組或多組長期存在的分支（main、release、uat、staging、test ...等），並透過 CI/CD 流程將對應分支的程式碼部署至指定環境。這樣一來，開發團隊就可以更精確地控制版本推進節奏，測試團隊可以針對特定版本進行驗收，而營運團隊也能逐步放量、降低風險。

總的來說，雖然 Git Flow、GitHub Flow、GitLab Flow 看似只是分支命名與合併順序的不同，但在實務操作中，它們背後所隱含的是對團隊協作模式、產品穩定性要求、交付頻率與風險控管的全面思考。比起盲目地認為「專案就是一定要用 xxx flow。」分析專案的開發環境、選擇一套適合自己團隊的開發流程，並持續根據實際狀況微調，才是長期維運與技術成長的關鍵。畢竟也沒有人說要一套用到底，或許在開發初期團隊選擇了 github flow 快速迭代；成長茁壯之後轉化成了 gitlab flow 進行多環境驗證；最後比起新功能，公司的方針慢慢偏向持續與穩定，這種時候如果再轉成 git flow，就是一個非常好的選擇。